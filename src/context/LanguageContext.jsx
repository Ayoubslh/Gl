import { createContext, useContext, useState, useEffect } from 'react';

const LanguageContext = createContext();

export const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
};

export const LanguageProvider = ({ children }) => {
  const [language, setLanguage] = useState(() => {
    const saved = localStorage.getItem('app-language');
    return saved || 'fr';
  });

  useEffect(() => {
    localStorage.setItem('app-language', language);
  }, [language]);

  const toggleLanguage = () => {
    setLanguage(prev => prev === 'fr' ? 'en' : 'fr');
  };

  const t = (key) => {
    const keys = key.split('.');
    let value = translations[language];
    
    for (const k of keys) {
      if (value && value[k]) {
        value = value[k];
      } else {
        return key;
      }
    }
    
    return value;
  };

  return (
    <LanguageContext.Provider value={{ language, setLanguage, toggleLanguage, t }}>
      {children}
    </LanguageContext.Provider>
  );
};

const translations = {
  fr: {
    nav: {
      home: 'Accueil',
      quiz: 'Quiz',
      chapters: 'Chapitres',
      chapter1: 'Ch.1 - Introduction au GL',
      chapter2: 'Ch.2 - Processus de Développement',
      chapter3: 'Ch.3 - Introduction à UML',
      chapter4: 'Ch.4 - Cas d\'Utilisation',
      chapter5: 'Ch.5 - Diagramme de Classes',
      chapter6: 'Ch.6 - Diagramme de Séquence',
      chapter7: 'Ch.7 - Diagramme d\'Activité',
      chapter8: 'Ch.8 - Diagramme d\'État',
    },
    home: {
      title: 'Révision Génie Logiciel',
      subtitle: 'Maîtrisez les concepts UML et le génie logiciel',
      description: 'Une application complète pour réviser les concepts du génie logiciel, les diagrammes UML avec des exemples visuels et des quiz interactifs.',
      startLearning: 'Commencer l\'apprentissage',
      takeQuiz: 'Passer le Quiz',
      chapters: 'Chapitres',
      features: {
        title: 'Fonctionnalités',
        visual: 'Diagrammes Visuels',
        visualDesc: 'Apprenez avec des diagrammes UML professionnels et interactifs',
        quiz: 'Quiz Interactifs',
        quizDesc: 'Testez vos connaissances avec des questions à choix multiples',
        comprehensive: 'Contenu Complet',
        comprehensiveDesc: 'Couvre tous les chapitres essentiels du génie logiciel',
      }
    },
    quiz: {
      title: 'Quiz de Révision',
      subtitle: 'Testez vos connaissances',
      question: 'Question',
      of: 'sur',
      submit: 'Valider',
      next: 'Suivante',
      previous: 'Précédente',
      finish: 'Terminer',
      restart: 'Recommencer',
      score: 'Score',
      correct: 'Correct !',
      incorrect: 'Incorrect',
      correctAnswer: 'La bonne réponse est',
      results: 'Résultats',
      yourScore: 'Votre score',
      excellent: 'Excellent ! Vous maîtrisez le sujet !',
      good: 'Bon travail ! Continuez à réviser.',
      needsWork: 'Continuez à étudier, vous pouvez vous améliorer !',
      filterByChapter: 'Filtrer par chapitre',
      allChapters: 'Tous les chapitres',
    },
    common: {
      chapter: 'Chapitre',
      definition: 'Définition',
      example: 'Exemple',
      examples: 'Exemples',
      note: 'Note',
      important: 'Important',
      summary: 'Résumé',
      objectives: 'Objectifs',
      introduction: 'Introduction',
      conclusion: 'Conclusion',
      characteristics: 'Caractéristiques',
      advantages: 'Avantages',
      disadvantages: 'Inconvénients',
      types: 'Types',
      elements: 'Éléments',
      notation: 'Notation',
      relations: 'Relations',
      diagram: 'Diagramme',
      keyPoints: 'Points Clés',
      remember: 'À Retenir',
      keyConcepts: 'Concepts Clés',
    },
    chapter1: {
      title: 'Introduction au Génie Logiciel',
      subtitle: 'Fondamentaux du développement logiciel et importance de l\'ingénierie',
      sections: { intro: 'Introduction', software: 'Logiciel', engineering: 'Génie Logiciel', crisis: 'Crise du Logiciel', quality: 'Qualité' },
      intro: {
        title: 'Qu\'est-ce que le Génie Logiciel ?',
        description: 'Le génie logiciel est l\'application d\'une approche systématique, disciplinée et quantifiable au développement, à l\'exploitation et à la maintenance du logiciel.',
        software: 'Logiciel', softwareDesc: 'Ensemble des programmes, procédures et documentation associée',
        engineering: 'Ingénierie', engineeringDesc: 'Application de principes scientifiques et mathématiques',
        process: 'Processus', processDesc: 'Ensemble structuré d\'activités pour le développement',
      },
      software: {
        title: 'Le Logiciel',
        definition: 'Un logiciel est un ensemble de programmes, de procédures, de règles et de documentation associée, relatifs au fonctionnement d\'un ensemble de traitement de l\'information.',
        typesTitle: 'Types de Logiciels',
        generic: 'Logiciel Générique', genericDesc: 'Produits autonomes vendus sur le marché ouvert',
        genericEx: ['Systèmes d\'exploitation', 'Traitements de texte', 'Navigateurs web'],
        custom: 'Logiciel Sur Mesure', customDesc: 'Systèmes commandés par un client particulier',
        customEx: ['Systèmes de contrôle', 'Systèmes de gestion spécifiques', 'Applications métier'],
        componentsTitle: 'Composants d\'un Logiciel',
        programs: 'Programmes', data: 'Données', documentation: 'Documentation',
      },
      engineering: {
        title: 'Le Génie Logiciel',
        ieeeTitle: 'Définition IEEE',
        ieeeText: '"Application d\'une approche systématique, disciplinée et quantifiable au développement, à l\'exploitation et à la maintenance du logiciel."',
        objectivesTitle: 'Objectifs du Génie Logiciel',
        obj1: 'Qualité', obj1Desc: 'Produire des logiciels de haute qualité répondant aux besoins',
        obj2: 'Délais', obj2Desc: 'Respecter les échéances de livraison',
        obj3: 'Coûts', obj3Desc: 'Maîtriser les coûts de développement',
        obj4: 'Maintenance', obj4Desc: 'Faciliter l\'évolution et la maintenance',
        principlesTitle: 'Principes Fondamentaux',
        p1: 'Rigueur et Formalisme', p1Desc: 'Utilisation de méthodes formelles et d\'outils pour garantir la qualité',
        p2: 'Séparation des préoccupations', p2Desc: 'Décomposition du problème en sous-problèmes indépendants',
        p3: 'Modularité', p3Desc: 'Division du système en modules indépendants et cohésifs',
        p4: 'Abstraction', p4Desc: 'Masquer les détails pour se concentrer sur l\'essentiel',
      },
      crisis: {
        title: 'La Crise du Logiciel',
        description: 'La "crise du logiciel" désigne les difficultés rencontrées dans le développement de logiciels depuis les années 1960.',
        cancelled: 'Projets annulés', overrun: 'Dépassement coûts/délais', success: 'Projets réussis',
        reasonsTitle: 'Causes de la Crise',
        r1: 'Complexité croissante', r1Desc: 'Les logiciels deviennent de plus en plus complexes',
        r2: 'Manque de méthodes', r2Desc: 'Absence de méthodologies de développement rigoureuses',
        r3: 'Gestion déficiente', r3Desc: 'Mauvaise estimation des coûts et des délais',
        r4: 'Communication', r4Desc: 'Difficultés de communication entre équipes',
      },
      quality: {
        title: 'Qualité du Logiciel',
        intro: 'La qualité d\'un logiciel se mesure par plusieurs facteurs essentiels.',
        validity: 'Validité', validityDesc: 'Aptitude à réaliser les tâches définies',
        reliability: 'Fiabilité', reliabilityDesc: 'Aptitude à fonctionner dans des conditions anormales',
        robustness: 'Robustesse', robustnessDesc: 'Aptitude à fonctionner même en dehors des conditions normales',
        extensibility: 'Extensibilité', extensibilityDesc: 'Facilité d\'adaptation aux changements',
        reusability: 'Réutilisabilité', reusabilityDesc: 'Aptitude à être réutilisé en tout ou partie',
        compatibility: 'Compatibilité', compatibilityDesc: 'Aptitude à être combiné avec d\'autres logiciels',
        efficiency: 'Efficacité', efficiencyDesc: 'Bonne utilisation des ressources matérielles',
        portability: 'Portabilité', portabilityDesc: 'Facilité de transfert vers d\'autres environnements',
        verifiability: 'Vérifiabilité', verifiabilityDesc: 'Facilité de préparation des procédures de test',
        integrity: 'Intégrité', integrityDesc: 'Protection contre les accès non autorisés',
      }
    },
    chapter2: {
      title: 'Processus de Développement Logiciel',
      subtitle: 'Modèles et méthodologies de développement',
      sections: { intro: 'Introduction', lifecycle: 'Cycle de Vie', models: 'Modèles', agile: 'Méthodes Agiles', comparison: 'Comparaison' },
      intro: {
        title: 'Processus de Développement',
        description: 'Un processus de développement logiciel définit les étapes et activités nécessaires pour produire un logiciel de qualité.',
        whatIs: 'Qu\'est-ce qu\'un Processus ?',
        processDesc: 'Un processus est un ensemble structuré d\'activités requises pour développer un système logiciel.',
      },
      lifecycle: {
        title: 'Cycle de Vie du Logiciel',
        description: 'Le cycle de vie comprend toutes les phases depuis la conception jusqu\'à la mise hors service.',
        analysis: 'Analyse des Besoins', analysisDesc: 'Comprendre et documenter les besoins des utilisateurs',
        specification: 'Spécification', specificationDesc: 'Définir précisément ce que le système doit faire',
        design: 'Conception', designDesc: 'Définir l\'architecture et la structure du système',
        implementation: 'Implémentation', implementationDesc: 'Écrire le code source du logiciel',
        testing: 'Tests', testingDesc: 'Vérifier que le logiciel fonctionne correctement',
        deployment: 'Déploiement', deploymentDesc: 'Installer le logiciel dans l\'environnement de production',
        maintenance: 'Maintenance', maintenanceDesc: 'Corriger les erreurs et améliorer le logiciel',
      },
      models: {
        title: 'Modèles de Développement',
        waterfall: 'Modèle en Cascade', waterfallDesc: 'Approche séquentielle où chaque phase doit être complétée avant de passer à la suivante.',
        waterfallAdv: ['Simple à comprendre', 'Phases bien définies', 'Documentation complète'],
        waterfallDis: ['Rigide', 'Pas de retour possible', 'Livraison tardive'],
        vmodel: 'Modèle en V', vmodelDesc: 'Extension du modèle en cascade avec des phases de tests associées.',
        vmodelAdv: ['Tests planifiés tôt', 'Qualité améliorée', 'Traçabilité'],
        vmodelDis: ['Toujours séquentiel', 'Peu flexible', 'Coûteux en tests'],
        spiral: 'Modèle en Spirale', spiralDesc: 'Modèle itératif qui met l\'accent sur l\'analyse des risques.',
        spiralAdv: ['Gestion des risques', 'Flexible', 'Adapté aux grands projets'],
        spiralDis: ['Complexe', 'Coûteux', 'Nécessite expertise'],
        incremental: 'Modèle Incrémental', incrementalDesc: 'Le système est développé et livré par incréments.',
        incrementalAdv: ['Livraison rapide', 'Retour utilisateur', 'Flexibilité'],
        incrementalDis: ['Architecture complexe', 'Intégration difficile'],
      },
      agile: {
        title: 'Méthodes Agiles',
        description: 'Approche itérative et incrémentale favorisant la collaboration et l\'adaptation au changement.',
        manifesto: 'Manifeste Agile',
        value1: 'Les individus et leurs interactions plus que les processus et les outils',
        value2: 'Un logiciel qui fonctionne plus qu\'une documentation exhaustive',
        value3: 'La collaboration avec les clients plus que la négociation contractuelle',
        value4: 'L\'adaptation au changement plus que le suivi d\'un plan',
        scrum: 'Scrum', scrumDesc: 'Framework agile basé sur des sprints de 2-4 semaines.',
        scrumRoles: ['Product Owner', 'Scrum Master', 'Équipe de développement'],
        scrumEvents: ['Sprint Planning', 'Daily Scrum', 'Sprint Review', 'Sprint Retrospective'],
        xp: 'Extreme Programming (XP)', xpDesc: 'Méthode agile mettant l\'accent sur les pratiques techniques.',
        xpPractices: ['Pair Programming', 'TDD', 'Intégration Continue', 'Refactoring'],
      },
      comparison: {
        title: 'Comparaison des Modèles',
        flexibility: 'Flexibilité', riskMgmt: 'Gestion des risques',
        clientInvolvement: 'Implication client', documentation: 'Documentation', deliverySpeed: 'Rapidité de livraison',
      },
      merise: {
        title: 'Méthode MERISE',
        definition: 'MERISE (Méthode d\'Étude et de Réalisation Informatique pour les Systèmes d\'Entreprise) est une méthode française de conception des systèmes d\'information, créée dans les années 1970.',
        cycles: 'Les 3 Cycles de MERISE',
        abstraction: 'Cycle d\'Abstraction',
        abstractionLevels: {
          conceptual: 'Conceptuel - QUOI ? (le métier)',
          logical: 'Logique/Organisationnel - QUI ? OÙ ? QUAND ?',
          physical: 'Physique - COMMENT ?'
        },
        decision: 'Cycle de Décision',
        decisionPhases: ['Étude préalable', 'Étude détaillée', 'Étude technique', 'Production'],
        lifecycle: 'Cycle de Vie',
        lifecyclePhases: ['Conception', 'Réalisation', 'Maintenance'],
        models: 'Modèles MERISE',
        level: 'Niveau',
        data: 'Données',
        treatments: 'Traitements'
      },
      up: {
        title: 'Processus Unifié (UP)',
        definition: 'Le Processus Unifié (UP - Unified Process) est un processus de développement logiciel itératif et incrémental, centré sur l\'architecture et piloté par les cas d\'utilisation.',
        characteristics: 'Caractéristiques Clés',
        iterative: 'Itératif',
        iterativeDesc: 'Le projet est découpé en itérations courtes avec des livrables à chaque cycle',
        incremental: 'Incrémental',
        incrementalDesc: 'Chaque itération ajoute de nouvelles fonctionnalités au système',
        architecture: 'Centré Architecture',
        architectureDesc: 'L\'architecture logicielle est au cœur du processus',
        useCaseDriven: 'Piloté par Use Cases',
        useCaseDrivenDesc: 'Les cas d\'utilisation guident le développement',
        phases: 'Les 4 Phases du UP',
        inception: 'Inception',
        inceptionTitle: 'Lancement',
        inceptionItems: ['Définir la portée du projet', 'Identifier les risques majeurs', 'Établir l\'étude de faisabilité'],
        elaboration: 'Élaboration',
        elaborationTitle: 'Planification',
        elaborationItems: ['Analyser le domaine', 'Établir l\'architecture', 'Éliminer les risques'],
        construction: 'Construction',
        constructionTitle: 'Développement',
        constructionItems: ['Développer le système', 'Réaliser les tests', 'Produire les versions bêta'],
        transition: 'Transition',
        transitionTitle: 'Déploiement',
        transitionItems: ['Déployer le système', 'Former les utilisateurs', 'Corriger les défauts'],
        disciplines: 'Disciplines du UP'
      },
      tup: {
        title: 'Processus 2TUP',
        definition: '2TUP (2 Track Unified Process) est un processus qui sépare les aspects fonctionnels et techniques du développement en deux branches parallèles qui fusionnent ensuite.',
        architecture: 'Architecture en Y',
        functional: 'Branche Fonctionnelle',
        functionalSteps: ['Capture des besoins fonctionnels', 'Analyse des besoins', 'Modélisation métier'],
        technical: 'Branche Technique',
        technicalSteps: ['Capture des besoins techniques', 'Conception générique', 'Architecture technique'],
        merge: 'Fusion',
        mergeSteps: ['Conception préliminaire', 'Conception détaillée', 'Codage & Tests', 'Recette & Déploiement'],
        advantages: 'Avantages du 2TUP',
        parallel: 'Parallélisation',
        parallelDesc: 'Les équipes fonctionnelles et techniques travaillent en parallèle',
        reuse: 'Réutilisation',
        reuseDesc: 'L\'architecture technique peut être réutilisée pour d\'autres projets',
        flexibility: 'Flexibilité',
        flexibilityDesc: 'Changements fonctionnels sans impact sur l\'architecture technique',
        specialization: 'Spécialisation',
        specializationDesc: 'Chaque équipe se concentre sur son domaine d\'expertise'
      },
      processIntro: {
        title: 'Introduction aux Processus de Développement',
        why: 'Pourquoi un processus de développement ?',
        whyDesc: 'Un processus de développement logiciel est un ensemble structuré d\'activités nécessaires pour transformer les besoins d\'un utilisateur en produit logiciel.',
        definition: 'Un processus définit QUI fait QUOI, QUAND et COMMENT pour atteindre un objectif donné.',
        lifecycle: 'Cycle de Vie',
        lifecycleDesc: 'Le cycle de vie du logiciel comprend toutes les phases depuis la conception jusqu\'à la maintenance et l\'évolution.',
        objectives: 'Garantir la qualité, respecter les délais, maîtriser les coûts et satisfaire les besoins des utilisateurs.',
        phases: 'Les Phases Classiques du Développement',
        phase1: 'Étude Préalable',
        phase1Desc: 'Analyse des besoins et faisabilité',
        phase2: 'Conception',
        phase2Desc: 'Architecture et modélisation',
        phase3: 'Réalisation',
        phase3Desc: 'Codage et tests unitaires',
        phase4: 'Mise en Œuvre',
        phase4Desc: 'Déploiement et formation'
      },
      comparisonTable: {
        criteria: 'Critère',
        origin: 'Origine',
        approach: 'Approche',
        focus: 'Focus',
        notation: 'Notation',
        flexibility: 'Flexibilité',
        france: 'France (1970s)',
        rational: 'Rational/IBM',
        valtech: 'Valtech',
        sequential: 'Séquentielle',
        iterative: 'Itérative',
        iterativeY: 'Itérative (Y)',
        dataFocus: 'Données',
        useCaseFocus: 'Use Cases',
        funcTechFocus: 'Fonc. + Tech.',
        ownNotation: 'Propre (MCD...)',
        uml: 'UML',
        low: 'Faible',
        high: 'Élevée',
        meriseSummary: 'Idéal pour les SI avec forte composante données. Approche structurée et rigoureuse.',
        upSummary: 'Processus flexible et adaptable. Standard de l\'industrie avec UML.',
        tupSummary: 'Séparation claire fonctionnel/technique. Permet la réutilisation.'
      }
    },
    chapter3: {
      title: 'Introduction à UML',
      subtitle: 'Unified Modeling Language - Langage de modélisation unifié',
      sections: { intro: 'Introduction', history: 'Historique', diagrams: 'Diagrammes', views: 'Vues 4+1' },
      intro: {
        title: 'Qu\'est-ce que UML ?',
        description: 'UML (Unified Modeling Language) est un langage de modélisation graphique standardisé pour visualiser, spécifier, construire et documenter les artefacts d\'un système logiciel.',
        purpose: 'UML permet de modéliser un système de manière visuelle et standardisée.',
        visualize: 'Visualiser', visualizeDesc: 'Représenter graphiquement le système',
        specify: 'Spécifier', specifyDesc: 'Décrire précisément les composants',
        construct: 'Construire', constructDesc: 'Guider l\'implémentation',
        document: 'Documenter', documentDesc: 'Créer une documentation claire',
      },
      history: {
        title: 'Historique d\'UML',
        description: 'UML a été créé dans les années 1990 par Grady Booch, James Rumbaugh et Ivar Jacobson.',
        early: 'Années 80-90: Plusieurs méthodes orientées objet (OMT, Booch, OOSE)',
        unification: '1994-1996: Unification des méthodes par les "3 amigos"',
        omg: '1997: Adoption par l\'OMG (Object Management Group)',
        current: 'Aujourd\'hui: UML 2.5 - Standard industriel',
        creators: 'Les "3 Amigos"',
        creatorsDesc: 'Grady Booch, James Rumbaugh et Ivar Jacobson',
      },
      diagrams: {
        title: 'Types de Diagrammes UML',
        structural: 'Diagrammes Structurels', structuralDesc: 'Représentent la structure statique du système',
        behavioral: 'Diagrammes Comportementaux', behavioralDesc: 'Représentent le comportement dynamique du système',
        class: 'Diagramme de Classes', object: 'Diagramme d\'Objets',
        component: 'Diagramme de Composants', deployment: 'Diagramme de Déploiement',
        package: 'Diagramme de Packages', composite: 'Diagramme de Structure Composite',
        useCase: 'Diagramme de Cas d\'Utilisation', sequence: 'Diagramme de Séquence',
        activity: 'Diagramme d\'Activité', state: 'Diagramme d\'État',
        communication: 'Diagramme de Communication', timing: 'Diagramme de Temps',
      },
      views: {
        title: 'Architecture 4+1 Vues',
        description: 'Philippe Kruchten a proposé une approche en 4+1 vues pour organiser la description d\'un système.',
        logical: 'Vue Logique', logicalDesc: 'Structure du système (classes, objets)',
        process: 'Vue des Processus', processDesc: 'Comportement dynamique (séquence, activité)',
        development: 'Vue de Développement', developmentDesc: 'Organisation du code (composants, packages)',
        physical: 'Vue Physique', physicalDesc: 'Infrastructure matérielle (déploiement)',
        useCase: 'Vue des Cas d\'Utilisation', useCaseDesc: 'Exigences fonctionnelles (cas d\'utilisation)',
      }
    },
    chapter4: {
      title: 'Diagramme de Cas d\'Utilisation',
      subtitle: 'Use Case Diagram - Modélisation des fonctionnalités',
      sections: { intro: 'Introduction', elements: 'Éléments', relations: 'Relations', example: 'Exemple', steps: 'Étapes' },
      intro: {
        title: 'Qu\'est-ce qu\'un Diagramme de Cas d\'Utilisation ?',
        description: 'Le diagramme de cas d\'utilisation représente les fonctionnalités du système du point de vue des utilisateurs.',
        purpose: 'Il montre QUI utilise le système et CE QU\'il peut faire avec.',
        when: 'Utilisé en phase d\'analyse des besoins pour capturer les exigences fonctionnelles.',
      },
      elements: {
        title: 'Éléments du Diagramme',
        actor: 'Acteur', actorDesc: 'Entité externe qui interagit avec le système.',
        actorTypes: ['Personne', 'Système externe', 'Temps', 'Matériel'],
        primary: 'Acteur Principal', primaryDesc: 'Initie le cas d\'utilisation',
        secondary: 'Acteur Secondaire', secondaryDesc: 'Participe au cas d\'utilisation',
        useCase: 'Cas d\'Utilisation', useCaseDesc: 'Fonctionnalité ou service offert par le système.',
        useCaseNaming: 'Nommé par un verbe à l\'infinitif (ex: "Retirer argent")',
        system: 'Système', systemDesc: 'Frontière délimitant le périmètre du système (rectangle).',
      },
      relations: {
        title: 'Relations',
        association: 'Association', associationDesc: 'Lien entre un acteur et un cas d\'utilisation.',
        include: 'Inclusion «include»', includeDesc: 'Un cas d\'utilisation inclut OBLIGATOIREMENT le comportement d\'un autre.',
        includeEx: '"Retirer Argent" inclut "S\'authentifier"',
        includeWhen: 'Pour factoriser un comportement commun obligatoire',
        extend: 'Extension «extend»', extendDesc: 'Un cas d\'utilisation peut OPTIONNELLEMENT étendre le comportement d\'un autre.',
        extendEx: '"Imprimer Reçu" étend "Retirer Argent"',
        extendWhen: 'Pour ajouter un comportement optionnel',
        generalization: 'Généralisation', generalizationDesc: 'Relation d\'héritage entre acteurs ou cas d\'utilisation.',
        generalizationEx: '"Client Premium" hérite de "Client"',
      },
      example: { title: 'Exemple: Système DAB', description: 'Diagramme de cas d\'utilisation pour un Distributeur Automatique de Billets' },
      steps: {
        title: 'Étapes de Construction',
        step1: 'Identifier les acteurs', step1Desc: 'Qui interagit avec le système ?',
        step2: 'Identifier les cas d\'utilisation', step2Desc: 'Que peut faire chaque acteur ?',
        step3: 'Définir les relations', step3Desc: 'Include, extend, généralisation',
        step4: 'Structurer le diagramme', step4Desc: 'Organiser et valider',
      }
    },
    chapter5: {
      title: 'Diagramme de Classes',
      subtitle: 'Class Diagram - Structure statique du système',
      sections: { intro: 'Introduction', class: 'Structure Classe', relations: 'Relations', example: 'Exemple', advanced: 'Avancé' },
      intro: {
        title: 'Qu\'est-ce qu\'un Diagramme de Classes ?',
        description: 'Le diagramme de classes représente la structure statique du système en montrant les classes, leurs attributs, méthodes et relations.',
        purpose: 'C\'est le diagramme le plus utilisé en UML - il sert de base pour l\'implémentation.',
        when: 'Utilisé en phase de conception pour définir l\'architecture logicielle.',
      },
      class: {
        title: 'Structure d\'une Classe',
        name: 'Nom de la classe',
        attributes: 'Attributs', attributesDesc: 'Propriétés/données de la classe',
        methods: 'Méthodes', methodsDesc: 'Opérations/comportements de la classe',
        visibilityTitle: 'Visibilité',
        public: 'Public (+) - Accessible partout',
        private: 'Privé (-) - Accessible dans la classe seulement',
        protected: 'Protégé (#) - Accessible dans la classe et ses sous-classes',
        package: 'Package (~) - Accessible dans le même package',
        notation: 'visibilité nom : type = valeurInitiale',
      },
      relations: {
        title: 'Relations entre Classes',
        association: 'Association', associationDesc: 'Relation structurelle entre deux classes.',
        aggregation: 'Agrégation', aggregationDesc: 'Relation "fait partie de" faible (losange vide).',
        aggregationEx: 'Une Équipe contient des Joueurs',
        composition: 'Composition', compositionDesc: 'Relation "fait partie de" forte (losange plein).',
        compositionEx: 'Une Maison contient des Pièces',
        inheritance: 'Héritage', inheritanceDesc: 'Relation "est un" (flèche triangulaire).',
        inheritanceEx: 'Un Chat est un Animal',
        dependency: 'Dépendance', dependencyDesc: 'Relation d\'utilisation temporaire (flèche pointillée).',
        realization: 'Réalisation', realizationDesc: 'Une classe implémente une interface.',
        multiplicityTitle: 'Multiplicité',
        mult1: '1 - Exactement un',
        mult01: '0..1 - Zéro ou un',
        mult0n: '0..* ou * - Zéro ou plusieurs',
        mult1n: '1..* - Un ou plusieurs',
        multnm: 'n..m - De n à m',
      },
      advanced: {
        abstractClass: 'Classe Abstraite', abstractClassDesc: 'Classe qui ne peut pas être instanciée (nom en italique)',
        interface: 'Interface', interfaceDesc: 'Contrat définissant des opérations «interface»',
        static: 'Membre Statique', staticDesc: 'Attribut ou méthode de classe (souligné)',
      },
      example: { title: 'Exemple: Système de Bibliothèque', description: 'Diagramme de classes pour un système de gestion de bibliothèque' }
    },
    chapter6: {
      title: 'Diagramme de Séquence',
      subtitle: 'Sequence Diagram - Interactions temporelles',
      sections: { intro: 'Introduction', elements: 'Éléments', messages: 'Messages', fragments: 'Fragments', example: 'Exemple' },
      intro: {
        title: 'Qu\'est-ce qu\'un Diagramme de Séquence ?',
        description: 'Le diagramme de séquence montre les interactions entre objets dans un ordre chronologique.',
        purpose: 'Il illustre COMMENT les objets collaborent pour réaliser un cas d\'utilisation.',
        when: 'Utilisé pour détailler le scénario d\'un cas d\'utilisation.',
        vertical: 'Axe vertical: le temps (de haut en bas)',
        horizontal: 'Axe horizontal: les objets participants',
      },
      elements: {
        title: 'Éléments du Diagramme',
        lifeline: 'Ligne de Vie', lifelineDesc: 'Représente un participant dans l\'interaction.',
        lifelineNotation: 'Rectangle + ligne verticale pointillée',
        lifelineFormat: 'nom : Type ou :Type',
        activation: 'Barre d\'Activation', activationDesc: 'Période pendant laquelle un objet exécute une action.',
        actor: 'Acteur', actorDesc: 'Initiateur de l\'interaction (souvent à gauche).',
      },
      messages: {
        title: 'Types de Messages',
        sync: 'Message Synchrone', syncDesc: 'L\'émetteur attend une réponse (flèche pleine).',
        async: 'Message Asynchrone', asyncDesc: 'L\'émetteur continue sans attendre (flèche ouverte).',
        return: 'Message de Retour', returnDesc: 'Réponse à un message (flèche pointillée).',
        create: 'Message de Création', createDesc: 'Crée une nouvelle instance.',
        destroy: 'Message de Destruction', destroyDesc: 'Détruit une instance (X).',
        self: 'Auto-message', selfDesc: 'Un objet s\'envoie un message à lui-même.',
      },
      fragments: {
        title: 'Fragments Combinés',
        description: 'Structurent les interactions avec des conditions et des boucles.',
        alt: 'alt (Alternative)', altDesc: 'Choix conditionnel entre plusieurs séquences (if-else).',
        opt: 'opt (Optionnel)', optDesc: 'Séquence exécutée si la condition est vraie.',
        loop: 'loop (Boucle)', loopDesc: 'Séquence répétée tant que la condition est vraie.',
        par: 'par (Parallèle)', parDesc: 'Séquences exécutées en parallèle.',
        ref: 'ref (Référence)', refDesc: 'Référence vers un autre diagramme de séquence.',
      },
      example: { title: 'Exemple: Authentification', description: 'Diagramme de séquence pour un processus d\'authentification' }
    },
    chapter7: {
      title: 'Diagramme d\'Activité',
      subtitle: 'Activity Diagram - Flux de contrôle',
      sections: { intro: 'Introduction', elements: 'Éléments', control: 'Contrôle de Flux', swimlanes: 'Couloirs', example: 'Exemple' },
      intro: {
        title: 'Qu\'est-ce qu\'un Diagramme d\'Activité ?',
        description: 'Le diagramme d\'activité modélise le flux de contrôle et de données d\'un processus ou d\'un algorithme.',
        purpose: 'Il montre COMMENT un processus se déroule, étape par étape.',
        when: 'Utilisé pour modéliser des processus métier, des algorithmes, des workflows.',
        similar: 'Similaire à un organigramme (flowchart) mais plus expressif.',
      },
      elements: {
        title: 'Éléments de Base',
        initial: 'Nœud Initial', initialDesc: 'Point de départ du flux (cercle plein).',
        final: 'Nœud Final', finalDesc: 'Point de terminaison (cercle avec point).',
        flowFinal: 'Fin de Flux', flowFinalDesc: 'Termine un flux sans terminer l\'activité.',
        action: 'Action/Activité', actionDesc: 'Tâche ou opération (rectangle arrondi).',
        object: 'Nœud Objet', objectDesc: 'Représente un objet ou des données.',
        flow: 'Flux/Transition', flowDesc: 'Passage d\'une activité à une autre (flèche).',
      },
      control: {
        title: 'Contrôle de Flux',
        decision: 'Décision', decisionDesc: 'Point de branchement conditionnel (losange).',
        guards: 'Gardes: conditions entre crochets [condition]',
        merge: 'Fusion', mergeDesc: 'Point de convergence des flux.',
        fork: 'Fork (Bifurcation)', forkDesc: 'Division en flux parallèles (barre).',
        join: 'Join (Synchronisation)', joinDesc: 'Synchronisation des flux parallèles.',
      },
      swimlanes: {
        title: 'Couloirs (Swimlanes)',
        description: 'Partitionnement du diagramme par responsabilité ou acteur.',
        purpose: 'Montrent QUI est responsable de chaque activité.',
        example: 'Client | Système | Banque',
      },
      example: { title: 'Exemple: Processus de Commande', description: 'Diagramme d\'activité pour un processus de commande en ligne' }
    },
    chapter8: {
      title: 'Diagramme d\'État',
      subtitle: 'State Machine Diagram - États et transitions',
      sections: { intro: 'Introduction', elements: 'Éléments', transitions: 'Transitions', composite: 'États Composites', example: 'Exemple' },
      intro: {
        title: 'Qu\'est-ce qu\'un Diagramme d\'État ?',
        description: 'Le diagramme d\'état modélise les différents états d\'un objet et les transitions entre ces états.',
        purpose: 'Il montre le cycle de vie d\'un objet en réponse aux événements.',
        when: 'Utilisé pour les objets avec un comportement dépendant de leur état.',
        focus: 'Focus sur UN seul objet et ses changements d\'état.',
      },
      elements: {
        title: 'Éléments de Base',
        state: 'État', stateDesc: 'Situation dans laquelle un objet se trouve.',
        stateEx: 'Éteint, Allumé, En attente',
        initial: 'État Initial', initialDesc: 'Point de départ (cercle plein).',
        final: 'État Final', finalDesc: 'Point de terminaison (cercle avec point).',
        actionsTitle: 'Actions Internes',
        entry: 'entry / action - Exécutée à l\'entrée',
        exit: 'exit / action - Exécutée à la sortie',
        do: 'do / activité - Continue pendant l\'état',
      },
      transitions: {
        title: 'Transitions',
        description: 'Passage d\'un état à un autre déclenché par un événement.',
        notation: 'événement [garde] / action',
        event: 'Événement', eventDesc: 'Déclencheur de la transition',
        guard: 'Garde', guardDesc: 'Condition optionnelle [entre crochets]',
        action: 'Action', actionDesc: 'Comportement exécuté lors de la transition',
        example: 'boutonPressé [estValide] / allumerLED',
        self: 'Auto-transition', selfDesc: 'Transition d\'un état vers lui-même.',
      },
      composite: {
        title: 'États Composites',
        description: 'État contenant des sous-états (hiérarchie d\'états).',
        substate: 'Sous-états', substateDesc: 'États imbriqués dans un état composite.',
        historyTitle: 'État Historique',
        shallow: 'H - Historique superficiel',
        deep: 'H* - Historique profond',
        concurrent: 'Régions Concurrentes', concurrentDesc: 'Sous-états exécutés en parallèle.',
      },
      example: {
        title: 'Exemple: Lecteur Audio',
        description: 'Diagramme d\'état pour un lecteur audio',
        stopped: 'Arrêté', playing: 'Lecture', paused: 'Pause',
      }
    },
  },

  // ENGLISH
  en: {
    nav: {
      home: 'Home',
      quiz: 'Quiz',
      chapters: 'Chapters',
      chapter1: 'Ch.1 - Introduction to SE',
      chapter2: 'Ch.2 - Development Process',
      chapter3: 'Ch.3 - Introduction to UML',
      chapter4: 'Ch.4 - Use Case Diagram',
      chapter5: 'Ch.5 - Class Diagram',
      chapter6: 'Ch.6 - Sequence Diagram',
      chapter7: 'Ch.7 - Activity Diagram',
      chapter8: 'Ch.8 - State Diagram',
    },
    home: {
      title: 'Software Engineering Review',
      subtitle: 'Master UML concepts and software engineering',
      description: 'A comprehensive application to review software engineering concepts, UML diagrams with visual examples and interactive quizzes.',
      startLearning: 'Start Learning',
      takeQuiz: 'Take the Quiz',
      chapters: 'Chapters',
      features: {
        title: 'Features',
        visual: 'Visual Diagrams',
        visualDesc: 'Learn with professional and interactive UML diagrams',
        quiz: 'Interactive Quizzes',
        quizDesc: 'Test your knowledge with multiple choice questions',
        comprehensive: 'Comprehensive Content',
        comprehensiveDesc: 'Covers all essential software engineering chapters',
      }
    },
    quiz: {
      title: 'Review Quiz',
      subtitle: 'Test your knowledge',
      question: 'Question',
      of: 'of',
      submit: 'Submit',
      next: 'Next',
      previous: 'Previous',
      finish: 'Finish',
      restart: 'Restart',
      score: 'Score',
      correct: 'Correct!',
      incorrect: 'Incorrect',
      correctAnswer: 'The correct answer is',
      results: 'Results',
      yourScore: 'Your score',
      excellent: 'Excellent! You have mastered the subject!',
      good: 'Good work! Keep reviewing.',
      needsWork: 'Keep studying, you can improve!',
      filterByChapter: 'Filter by chapter',
      allChapters: 'All chapters',
    },
    common: {
      chapter: 'Chapter',
      definition: 'Definition',
      example: 'Example',
      examples: 'Examples',
      note: 'Note',
      important: 'Important',
      summary: 'Summary',
      objectives: 'Objectives',
      introduction: 'Introduction',
      conclusion: 'Conclusion',
      characteristics: 'Characteristics',
      advantages: 'Advantages',
      disadvantages: 'Disadvantages',
      types: 'Types',
      elements: 'Elements',
      notation: 'Notation',
      relations: 'Relations',
      diagram: 'Diagram',
      keyPoints: 'Key Points',
      remember: 'Remember',
      keyConcepts: 'Key Concepts',
    },
    chapter1: {
      title: 'Introduction to Software Engineering',
      subtitle: 'Fundamentals of software development and importance of engineering',
      sections: { intro: 'Introduction', software: 'Software', engineering: 'Software Engineering', crisis: 'Software Crisis', quality: 'Quality' },
      intro: {
        title: 'What is Software Engineering?',
        description: 'Software engineering is the application of a systematic, disciplined, and quantifiable approach to the development, operation, and maintenance of software.',
        software: 'Software', softwareDesc: 'Set of programs, procedures, and associated documentation',
        engineering: 'Engineering', engineeringDesc: 'Application of scientific and mathematical principles',
        process: 'Process', processDesc: 'Structured set of activities for development',
      },
      software: {
        title: 'Software',
        definition: 'Software is a set of programs, procedures, rules, and associated documentation related to the operation of an information processing system.',
        typesTitle: 'Types of Software',
        generic: 'Generic Software', genericDesc: 'Standalone products sold on the open market',
        genericEx: ['Operating systems', 'Word processors', 'Web browsers'],
        custom: 'Custom Software', customDesc: 'Systems commissioned by a particular client',
        customEx: ['Control systems', 'Specific management systems', 'Business applications'],
        componentsTitle: 'Software Components',
        programs: 'Programs', data: 'Data', documentation: 'Documentation',
      },
      engineering: {
        title: 'Software Engineering',
        ieeeTitle: 'IEEE Definition',
        ieeeText: '"The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software."',
        objectivesTitle: 'Software Engineering Objectives',
        obj1: 'Quality', obj1Desc: 'Produce high-quality software that meets needs',
        obj2: 'Deadlines', obj2Desc: 'Meet delivery deadlines',
        obj3: 'Costs', obj3Desc: 'Control development costs',
        obj4: 'Maintenance', obj4Desc: 'Facilitate evolution and maintenance',
        principlesTitle: 'Fundamental Principles',
        p1: 'Rigor and Formalism', p1Desc: 'Use of formal methods and tools to ensure quality',
        p2: 'Separation of Concerns', p2Desc: 'Decomposition of the problem into independent sub-problems',
        p3: 'Modularity', p3Desc: 'Division of the system into independent and cohesive modules',
        p4: 'Abstraction', p4Desc: 'Hide details to focus on essentials',
      },
      crisis: {
        title: 'The Software Crisis',
        description: 'The "software crisis" refers to difficulties in software development since the 1960s.',
        cancelled: 'Cancelled projects', overrun: 'Cost/time overrun', success: 'Successful projects',
        reasonsTitle: 'Causes of the Crisis',
        r1: 'Increasing complexity', r1Desc: 'Software is becoming more and more complex',
        r2: 'Lack of methods', r2Desc: 'Absence of rigorous development methodologies',
        r3: 'Poor management', r3Desc: 'Poor estimation of costs and deadlines',
        r4: 'Communication', r4Desc: 'Communication difficulties between teams',
      },
      quality: {
        title: 'Software Quality',
        intro: 'Software quality is measured by several essential factors.',
        validity: 'Validity', validityDesc: 'Ability to perform defined tasks',
        reliability: 'Reliability', reliabilityDesc: 'Ability to function under abnormal conditions',
        robustness: 'Robustness', robustnessDesc: 'Ability to function outside normal conditions',
        extensibility: 'Extensibility', extensibilityDesc: 'Ease of adapting to changes',
        reusability: 'Reusability', reusabilityDesc: 'Ability to be reused',
        compatibility: 'Compatibility', compatibilityDesc: 'Ability to be combined with other software',
        efficiency: 'Efficiency', efficiencyDesc: 'Good use of hardware resources',
        portability: 'Portability', portabilityDesc: 'Ease of transfer to other environments',
        verifiability: 'Verifiability', verifiabilityDesc: 'Ease of preparing test procedures',
        integrity: 'Integrity', integrityDesc: 'Protection against unauthorized access',
      }
    },
    chapter2: {
      title: 'Software Development Process',
      subtitle: 'Development models and methodologies',
      sections: { intro: 'Introduction', lifecycle: 'Lifecycle', models: 'Models', agile: 'Agile Methods', comparison: 'Comparison' },
      intro: {
        title: 'Development Process',
        description: 'A software development process defines the steps and activities necessary to produce quality software.',
        whatIs: 'What is a Process?',
        processDesc: 'A process is a structured set of activities required to develop a software system.',
      },
      lifecycle: {
        title: 'Software Lifecycle',
        description: 'The lifecycle includes all phases from conception to decommissioning.',
        analysis: 'Requirements Analysis', analysisDesc: 'Understand and document user needs',
        specification: 'Specification', specificationDesc: 'Define precisely what the system must do',
        design: 'Design', designDesc: 'Define the architecture and structure',
        implementation: 'Implementation', implementationDesc: 'Write the software source code',
        testing: 'Testing', testingDesc: 'Verify that the software works correctly',
        deployment: 'Deployment', deploymentDesc: 'Install in the production environment',
        maintenance: 'Maintenance', maintenanceDesc: 'Fix errors and improve the software',
      },
      models: {
        title: 'Development Models',
        waterfall: 'Waterfall Model', waterfallDesc: 'Sequential approach where each phase must be completed before moving to the next.',
        waterfallAdv: ['Simple to understand', 'Well-defined phases', 'Complete documentation'],
        waterfallDis: ['Rigid', 'No backtracking', 'Late delivery'],
        vmodel: 'V-Model', vmodelDesc: 'Extension of waterfall with associated test phases.',
        vmodelAdv: ['Early test planning', 'Improved quality', 'Traceability'],
        vmodelDis: ['Still sequential', 'Inflexible', 'Expensive testing'],
        spiral: 'Spiral Model', spiralDesc: 'Iterative model emphasizing risk analysis.',
        spiralAdv: ['Risk management', 'Flexible', 'Suitable for large projects'],
        spiralDis: ['Complex', 'Expensive', 'Requires expertise'],
        incremental: 'Incremental Model', incrementalDesc: 'System developed and delivered in increments.',
        incrementalAdv: ['Fast delivery', 'User feedback', 'Flexibility'],
        incrementalDis: ['Complex architecture', 'Difficult integration'],
      },
      agile: {
        title: 'Agile Methods',
        description: 'Iterative and incremental approach favoring collaboration and adaptation to change.',
        manifesto: 'Agile Manifesto',
        value1: 'Individuals and interactions over processes and tools',
        value2: 'Working software over comprehensive documentation',
        value3: 'Customer collaboration over contract negotiation',
        value4: 'Responding to change over following a plan',
        scrum: 'Scrum', scrumDesc: 'Agile framework based on 2-4 week sprints.',
        scrumRoles: ['Product Owner', 'Scrum Master', 'Development Team'],
        scrumEvents: ['Sprint Planning', 'Daily Scrum', 'Sprint Review', 'Sprint Retrospective'],
        xp: 'Extreme Programming (XP)', xpDesc: 'Agile method emphasizing technical practices.',
        xpPractices: ['Pair Programming', 'TDD', 'Continuous Integration', 'Refactoring'],
      },
      comparison: {
        title: 'Model Comparison',
        flexibility: 'Flexibility', riskMgmt: 'Risk Management',
        clientInvolvement: 'Client Involvement', documentation: 'Documentation', deliverySpeed: 'Delivery Speed',
      },
      merise: {
        title: 'MERISE Method',
        definition: 'MERISE (Study and Implementation Method for Computer Systems) is a French method for designing information systems, created in the 1970s.',
        cycles: 'The 3 MERISE Cycles',
        abstraction: 'Abstraction Cycle',
        abstractionLevels: {
          conceptual: 'Conceptual - WHAT? (the business)',
          logical: 'Logical/Organizational - WHO? WHERE? WHEN?',
          physical: 'Physical - HOW?'
        },
        decision: 'Decision Cycle',
        decisionPhases: ['Preliminary study', 'Detailed study', 'Technical study', 'Production'],
        lifecycle: 'Lifecycle',
        lifecyclePhases: ['Design', 'Implementation', 'Maintenance'],
        models: 'MERISE Models',
        level: 'Level',
        data: 'Data',
        treatments: 'Treatments'
      },
      up: {
        title: 'Unified Process (UP)',
        definition: 'The Unified Process (UP) is an iterative and incremental software development process, architecture-centered and use case driven.',
        characteristics: 'Key Characteristics',
        iterative: 'Iterative',
        iterativeDesc: 'The project is divided into short iterations with deliverables at each cycle',
        incremental: 'Incremental',
        incrementalDesc: 'Each iteration adds new features to the system',
        architecture: 'Architecture-Centered',
        architectureDesc: 'Software architecture is at the heart of the process',
        useCaseDriven: 'Use Case Driven',
        useCaseDrivenDesc: 'Use cases guide development',
        phases: 'The 4 UP Phases',
        inception: 'Inception',
        inceptionTitle: 'Launch',
        inceptionItems: ['Define project scope', 'Identify major risks', 'Establish feasibility study'],
        elaboration: 'Elaboration',
        elaborationTitle: 'Planning',
        elaborationItems: ['Analyze the domain', 'Establish architecture', 'Eliminate risks'],
        construction: 'Construction',
        constructionTitle: 'Development',
        constructionItems: ['Develop the system', 'Perform tests', 'Produce beta versions'],
        transition: 'Transition',
        transitionTitle: 'Deployment',
        transitionItems: ['Deploy the system', 'Train users', 'Fix defects'],
        disciplines: 'UP Disciplines'
      },
      tup: {
        title: '2TUP Process',
        definition: '2TUP (2 Track Unified Process) is a process that separates functional and technical aspects of development into two parallel branches that then merge.',
        architecture: 'Y Architecture',
        functional: 'Functional Branch',
        functionalSteps: ['Capture functional requirements', 'Requirements analysis', 'Business modeling'],
        technical: 'Technical Branch',
        technicalSteps: ['Capture technical requirements', 'Generic design', 'Technical architecture'],
        merge: 'Merge',
        mergeSteps: ['Preliminary design', 'Detailed design', 'Coding & Testing', 'Acceptance & Deployment'],
        advantages: '2TUP Advantages',
        parallel: 'Parallelization',
        parallelDesc: 'Functional and technical teams work in parallel',
        reuse: 'Reuse',
        reuseDesc: 'Technical architecture can be reused for other projects',
        flexibility: 'Flexibility',
        flexibilityDesc: 'Functional changes without impact on technical architecture',
        specialization: 'Specialization',
        specializationDesc: 'Each team focuses on their area of expertise'
      },
      processIntro: {
        title: 'Introduction to Development Processes',
        why: 'Why a development process?',
        whyDesc: 'A software development process is a structured set of activities necessary to transform user needs into software product.',
        definition: 'A process defines WHO does WHAT, WHEN and HOW to achieve a given objective.',
        lifecycle: 'Lifecycle',
        lifecycleDesc: 'The software lifecycle includes all phases from design to maintenance and evolution.',
        objectives: 'Ensure quality, meet deadlines, control costs and satisfy user needs.',
        phases: 'Classic Development Phases',
        phase1: 'Preliminary Study',
        phase1Desc: 'Needs analysis and feasibility',
        phase2: 'Design',
        phase2Desc: 'Architecture and modeling',
        phase3: 'Implementation',
        phase3Desc: 'Coding and unit testing',
        phase4: 'Deployment',
        phase4Desc: 'Deployment and training'
      },
      comparisonTable: {
        criteria: 'Criteria',
        origin: 'Origin',
        approach: 'Approach',
        focus: 'Focus',
        notation: 'Notation',
        flexibility: 'Flexibility',
        france: 'France (1970s)',
        rational: 'Rational/IBM',
        valtech: 'Valtech',
        sequential: 'Sequential',
        iterative: 'Iterative',
        iterativeY: 'Iterative (Y)',
        dataFocus: 'Data',
        useCaseFocus: 'Use Cases',
        funcTechFocus: 'Func. + Tech.',
        ownNotation: 'Own (MCD...)',
        uml: 'UML',
        low: 'Low',
        high: 'High',
        meriseSummary: 'Ideal for IS with strong data component. Structured and rigorous approach.',
        upSummary: 'Flexible and adaptable process. Industry standard with UML.',
        tupSummary: 'Clear functional/technical separation. Allows reuse.'
      }
    },
    chapter3: {
      title: 'Introduction to UML',
      subtitle: 'Unified Modeling Language',
      sections: { intro: 'Introduction', history: 'History', diagrams: 'Diagrams', views: '4+1 Views' },
      intro: {
        title: 'What is UML?',
        description: 'UML (Unified Modeling Language) is a standardized graphical modeling language for visualizing, specifying, constructing, and documenting software system artifacts.',
        purpose: 'UML allows modeling a system in a visual and standardized way.',
        visualize: 'Visualize', visualizeDesc: 'Graphically represent the system',
        specify: 'Specify', specifyDesc: 'Precisely describe components',
        construct: 'Construct', constructDesc: 'Guide implementation',
        document: 'Document', documentDesc: 'Create clear documentation',
      },
      history: {
        title: 'UML History',
        description: 'UML was created in the 1990s by Grady Booch, James Rumbaugh, and Ivar Jacobson.',
        early: '1980s-90s: Several object-oriented methods (OMT, Booch, OOSE)',
        unification: '1994-1996: Unification of methods by the "3 amigos"',
        omg: '1997: Adoption by OMG (Object Management Group)',
        current: 'Today: UML 2.5 - Industry standard',
        creators: 'The "3 Amigos"',
        creatorsDesc: 'Grady Booch, James Rumbaugh, and Ivar Jacobson',
      },
      diagrams: {
        title: 'UML Diagram Types',
        structural: 'Structural Diagrams', structuralDesc: 'Represent the static structure',
        behavioral: 'Behavioral Diagrams', behavioralDesc: 'Represent dynamic behavior',
        class: 'Class Diagram', object: 'Object Diagram',
        component: 'Component Diagram', deployment: 'Deployment Diagram',
        package: 'Package Diagram', composite: 'Composite Structure Diagram',
        useCase: 'Use Case Diagram', sequence: 'Sequence Diagram',
        activity: 'Activity Diagram', state: 'State Diagram',
        communication: 'Communication Diagram', timing: 'Timing Diagram',
      },
      views: {
        title: '4+1 View Architecture',
        description: 'Philippe Kruchten proposed a 4+1 view approach to organize system description.',
        logical: 'Logical View', logicalDesc: 'System structure (classes, objects)',
        process: 'Process View', processDesc: 'Dynamic behavior (sequence, activity)',
        development: 'Development View', developmentDesc: 'Code organization (components, packages)',
        physical: 'Physical View', physicalDesc: 'Hardware infrastructure (deployment)',
        useCase: 'Use Case View', useCaseDesc: 'Functional requirements (use cases)',
      }
    },
    chapter4: {
      title: 'Use Case Diagram',
      subtitle: 'Use Case Diagram - Functionality Modeling',
      sections: { intro: 'Introduction', elements: 'Elements', relations: 'Relations', example: 'Example', steps: 'Steps' },
      intro: {
        title: 'What is a Use Case Diagram?',
        description: 'The use case diagram represents system functionalities from the users\' point of view.',
        purpose: 'It shows WHO uses the system and WHAT they can do with it.',
        when: 'Used during requirements analysis to capture functional requirements.',
      },
      elements: {
        title: 'Diagram Elements',
        actor: 'Actor', actorDesc: 'External entity that interacts with the system.',
        actorTypes: ['Person', 'External system', 'Time', 'Hardware'],
        primary: 'Primary Actor', primaryDesc: 'Initiates the use case',
        secondary: 'Secondary Actor', secondaryDesc: 'Participates in the use case',
        useCase: 'Use Case', useCaseDesc: 'Functionality or service offered by the system.',
        useCaseNaming: 'Named with an infinitive verb (e.g., "Withdraw money")',
        system: 'System', systemDesc: 'Boundary delimiting the system scope (rectangle).',
      },
      relations: {
        title: 'Relations',
        association: 'Association', associationDesc: 'Link between an actor and a use case.',
        include: 'Include «include»', includeDesc: 'A use case MANDATORILY includes another\'s behavior.',
        includeEx: '"Withdraw Money" includes "Authenticate"',
        includeWhen: 'To factor out mandatory common behavior',
        extend: 'Extend «extend»', extendDesc: 'A use case can OPTIONALLY extend another\'s behavior.',
        extendEx: '"Print Receipt" extends "Withdraw Money"',
        extendWhen: 'To add optional behavior',
        generalization: 'Generalization', generalizationDesc: 'Inheritance relationship between actors or use cases.',
        generalizationEx: '"Premium Client" inherits from "Client"',
      },
      example: { title: 'Example: ATM System', description: 'Use case diagram for an Automated Teller Machine' },
      steps: {
        title: 'Construction Steps',
        step1: 'Identify actors', step1Desc: 'Who interacts with the system?',
        step2: 'Identify use cases', step2Desc: 'What can each actor do?',
        step3: 'Define relations', step3Desc: 'Include, extend, generalization',
        step4: 'Structure the diagram', step4Desc: 'Organize and validate',
      }
    },
    chapter5: {
      title: 'Class Diagram',
      subtitle: 'Class Diagram - Static System Structure',
      sections: { intro: 'Introduction', class: 'Class Structure', relations: 'Relations', example: 'Example', advanced: 'Advanced' },
      intro: {
        title: 'What is a Class Diagram?',
        description: 'The class diagram represents the static structure of the system by showing classes, their attributes, methods, and relationships.',
        purpose: 'It is the most used diagram in UML - it serves as the basis for implementation.',
        when: 'Used during design phase to define software architecture.',
      },
      class: {
        title: 'Class Structure',
        name: 'Class name',
        attributes: 'Attributes', attributesDesc: 'Properties/data of the class',
        methods: 'Methods', methodsDesc: 'Operations/behaviors of the class',
        visibilityTitle: 'Visibility',
        public: 'Public (+) - Accessible everywhere',
        private: 'Private (-) - Accessible only within the class',
        protected: 'Protected (#) - Accessible in class and subclasses',
        package: 'Package (~) - Accessible in the same package',
        notation: 'visibility name : type = initialValue',
      },
      relations: {
        title: 'Relationships Between Classes',
        association: 'Association', associationDesc: 'Structural relationship between two classes.',
        aggregation: 'Aggregation', aggregationDesc: 'Weak "part of" relationship (empty diamond).',
        aggregationEx: 'A Team contains Players',
        composition: 'Composition', compositionDesc: 'Strong "part of" relationship (filled diamond).',
        compositionEx: 'A House contains Rooms',
        inheritance: 'Inheritance', inheritanceDesc: '"Is a" relationship (triangular arrow).',
        inheritanceEx: 'A Cat is an Animal',
        dependency: 'Dependency', dependencyDesc: 'Temporary usage relationship (dashed arrow).',
        realization: 'Realization', realizationDesc: 'A class implements an interface.',
        multiplicityTitle: 'Multiplicity',
        mult1: '1 - Exactly one',
        mult01: '0..1 - Zero or one',
        mult0n: '0..* or * - Zero or many',
        mult1n: '1..* - One or many',
        multnm: 'n..m - From n to m',
      },
      advanced: {
        abstractClass: 'Abstract Class', abstractClassDesc: 'Class that cannot be instantiated (name in italics)',
        interface: 'Interface', interfaceDesc: 'Contract defining operations «interface»',
        static: 'Static Member', staticDesc: 'Class attribute or method (underlined)',
      },
      example: { title: 'Example: Library System', description: 'Class diagram for a library management system' }
    },
    chapter6: {
      title: 'Sequence Diagram',
      subtitle: 'Sequence Diagram - Temporal Interactions',
      sections: { intro: 'Introduction', elements: 'Elements', messages: 'Messages', fragments: 'Fragments', example: 'Example' },
      intro: {
        title: 'What is a Sequence Diagram?',
        description: 'The sequence diagram shows interactions between objects in chronological order.',
        purpose: 'It illustrates HOW objects collaborate to realize a use case.',
        when: 'Used to detail a use case scenario.',
        vertical: 'Vertical axis: time (top to bottom)',
        horizontal: 'Horizontal axis: participating objects',
      },
      elements: {
        title: 'Diagram Elements',
        lifeline: 'Lifeline', lifelineDesc: 'Represents a participant in the interaction.',
        lifelineNotation: 'Rectangle + vertical dashed line',
        lifelineFormat: 'name : Type or :Type',
        activation: 'Activation Bar', activationDesc: 'Period during which an object executes an action.',
        actor: 'Actor', actorDesc: 'Initiator of the interaction (often on the left).',
      },
      messages: {
        title: 'Message Types',
        sync: 'Synchronous Message', syncDesc: 'The sender waits for a response (solid arrow).',
        async: 'Asynchronous Message', asyncDesc: 'The sender continues without waiting (open arrow).',
        return: 'Return Message', returnDesc: 'Response to a message (dashed arrow).',
        create: 'Create Message', createDesc: 'Creates a new instance.',
        destroy: 'Destroy Message', destroyDesc: 'Destroys an instance (X).',
        self: 'Self Message', selfDesc: 'An object sends a message to itself.',
      },
      fragments: {
        title: 'Combined Fragments',
        description: 'Structure interactions with conditions and loops.',
        alt: 'alt (Alternative)', altDesc: 'Conditional choice between multiple sequences (if-else).',
        opt: 'opt (Optional)', optDesc: 'Sequence executed if condition is true.',
        loop: 'loop', loopDesc: 'Sequence repeated while condition is true.',
        par: 'par (Parallel)', parDesc: 'Sequences executed in parallel.',
        ref: 'ref (Reference)', refDesc: 'Reference to another sequence diagram.',
      },
      example: { title: 'Example: Authentication', description: 'Sequence diagram for an authentication process' }
    },
    chapter7: {
      title: 'Activity Diagram',
      subtitle: 'Activity Diagram - Control Flow',
      sections: { intro: 'Introduction', elements: 'Elements', control: 'Flow Control', swimlanes: 'Swimlanes', example: 'Example' },
      intro: {
        title: 'What is an Activity Diagram?',
        description: 'The activity diagram models the control and data flow of a process or algorithm.',
        purpose: 'It shows HOW a process unfolds, step by step.',
        when: 'Used to model business processes, algorithms, workflows.',
        similar: 'Similar to a flowchart but more expressive.',
      },
      elements: {
        title: 'Basic Elements',
        initial: 'Initial Node', initialDesc: 'Flow starting point (filled circle).',
        final: 'Final Node', finalDesc: 'Termination point (circle with dot).',
        flowFinal: 'Flow Final', flowFinalDesc: 'Terminates a flow without ending the activity.',
        action: 'Action/Activity', actionDesc: 'Task or operation (rounded rectangle).',
        object: 'Object Node', objectDesc: 'Represents an object or data.',
        flow: 'Flow/Transition', flowDesc: 'Passage from one activity to another (arrow).',
      },
      control: {
        title: 'Flow Control',
        decision: 'Decision', decisionDesc: 'Conditional branching point (diamond).',
        guards: 'Guards: conditions in brackets [condition]',
        merge: 'Merge', mergeDesc: 'Flow convergence point.',
        fork: 'Fork', forkDesc: 'Division into parallel flows (bar).',
        join: 'Join', joinDesc: 'Synchronization of parallel flows.',
      },
      swimlanes: {
        title: 'Swimlanes',
        description: 'Partitioning of the diagram by responsibility or actor.',
        purpose: 'Show WHO is responsible for each activity.',
        example: 'Customer | System | Bank',
      },
      example: { title: 'Example: Order Process', description: 'Activity diagram for an online ordering process' }
    },
    chapter8: {
      title: 'State Diagram',
      subtitle: 'State Machine Diagram - States and Transitions',
      sections: { intro: 'Introduction', elements: 'Elements', transitions: 'Transitions', composite: 'Composite States', example: 'Example' },
      intro: {
        title: 'What is a State Diagram?',
        description: 'The state diagram models the different states of an object and the transitions between these states.',
        purpose: 'It shows the lifecycle of an object in response to events.',
        when: 'Used for objects with behavior dependent on their state.',
        focus: 'Focus on ONE single object and its state changes.',
      },
      elements: {
        title: 'Basic Elements',
        state: 'State', stateDesc: 'Situation in which an object finds itself.',
        stateEx: 'Off, On, Waiting',
        initial: 'Initial State', initialDesc: 'Starting point (filled circle).',
        final: 'Final State', finalDesc: 'Termination point (circle with dot).',
        actionsTitle: 'Internal Actions',
        entry: 'entry / action - Executed on entering',
        exit: 'exit / action - Executed on exiting',
        do: 'do / activity - Continuous during the state',
      },
      transitions: {
        title: 'Transitions',
        description: 'Passage from one state to another triggered by an event.',
        notation: 'event [guard] / action',
        event: 'Event', eventDesc: 'Trigger of the transition',
        guard: 'Guard', guardDesc: 'Optional condition [in brackets]',
        action: 'Action', actionDesc: 'Behavior executed during transition',
        example: 'buttonPressed [isValid] / turnOnLED',
        self: 'Self-transition', selfDesc: 'Transition from a state to itself.',
      },
      composite: {
        title: 'Composite States',
        description: 'State containing sub-states (state hierarchy).',
        substate: 'Sub-states', substateDesc: 'States nested within a composite state.',
        historyTitle: 'History State',
        shallow: 'H - Shallow history',
        deep: 'H* - Deep history',
        concurrent: 'Concurrent Regions', concurrentDesc: 'Sub-states executed in parallel.',
      },
      example: {
        title: 'Example: Audio Player',
        description: 'State diagram for an audio player',
        stopped: 'Stopped', playing: 'Playing', paused: 'Paused',
      }
    },
  }
};

export default LanguageContext;
